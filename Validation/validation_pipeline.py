import os
from typing import List, Dict, Any

class ValidationPipeline:
    """Pipeline for validating code files generated by the LLM"""
  
    def __init__(self, output_dir: str, source_dir: str):
        """
        Initialize the pipeline.
    
        Args:
            output_dir: directory to write output files to for various tools
                        (this means captured `stdout` and `stderr` streams)
            source_dir: directory containing the code files generated by the LLM
        """
        self.output_dir = output_dir
        self.source_dir = source_dir

        # Pipeline stages
        # self.compilation = CompilationStage(output_dir)
        # self.static_analysis = StaticAnalysisStage(output_dir)

        # To be implemented in future sprints
        # ====================================
        # self.dynamic_analysis = DynamicAnalysisStage(output_dir)
        # self.style_analysis = StyleAnalysisStage(output_dir)
        # self.unit_tester = UnitTestStage(output_dir)

    def run(self) -> Dict[str, Dict[str, Any]]:
        """
        Run the pipeline

        Returns:
            A dictionary mapping the name of validation stage to a 
            collection of outputs associated with that stage:
                - success/failure of stage
                - generated errors/warnings
                - stdout/stderr
                - any misc. artifacts
        """
        results = {}

        # Containers to collect source code and header
        # files from LLM/output directory
        c_files, h_files, build_tool = self.collect_file_paths()

        # Stage 1: Compilation
        results["compilation"] = self.compilation.run(
            source_files=c_files,
            header_files=h_files,
            build_tool=build_tool
        )

        # Stage 2: Static Analysis
        # results["static_analysis"] = self.static_analysis.run()

        # Further steps to be implemented later...

        return results

    def collect_file_paths(self) -> (List[str], List[str], str):
        """
        Iterate thru LLM output directory and extract:
            - .c files
            - .h files
            - any build system (make, cmake) if one exists, else None

        Returns:
            (c_files, h_files, build_tool)
        """
        # Containers to store paths to files in source directory
        c_files = []
        h_files = []
        build_tool = None  # Will become "make" or "cmake" if build file encountered

        # Traverses all file paths in source directory
        for root, dirs, files in os.walk(self.source_dir, topdown=True):
            for filename in files:
                if filename.endswith(".c"):
                    c_files.append(os.path.join(root, filename))
                elif filename.endswith(".h"):
                    h_files.append(os.path.join(root, filename))
                elif filename == "Makefile":
                    build_tool = "make"
                elif filename == "CMakeLists.txt":
                    build_tool = "cmake"

        return c_files, h_files, build_tool
